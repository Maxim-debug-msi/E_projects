#include <iostream>
#include <vector>
#include <map>

class IGraph {

public:

    virtual ~IGraph() = default;

    IGraph() = default; // нужно реализовать в наследниках тоже

    explicit IGraph(IGraph* _oth){}; // нужно реализовать в наследниках тоже

    virtual void AddEdge(int from, int to) = 0; // Метод принимает вершины начала и конца ребра и добавляет ребро

    virtual int VerticesCount() const = 0; // Метод должен считать текущее количество вершин

    virtual std::vector<int> Vertices() const = 0; // Метод должен вернуть текущие список текущих вершин

    virtual std::vector<int> GetNextVertices(int vertex) const = 0; // Для конкретной вершины метод возвращает вектор с вершинами, в которые можно дойти по ребру из данной

    virtual std::vector<int> GetPrevVertices(int vertex) const = 0; // Для конкретной вершины метод возвращает вектор с вершинами, из которых можно дойти по ребру в данную

    virtual void get_param_m(std::map<int, std::vector<int>>& list_to, std::map<int, std::vector<int>>& list_from, int& v) const{};

    virtual void get_param_l(std::vector<int>& index2Vertex, std::map<int, int>& vertex2Index, std::vector<std::vector<int>>& matrix, int& v) const{};

};

class ListGraph : public IGraph{
public:
    ~ListGraph() override = default;

    ListGraph() = default;

    void init(int& size){
        v = size;
        for(int i{1}; i <= size; ++i){
            list_to[i];
            list_from[i];
        }
    }

    ListGraph(const ListGraph& _oth) = default;

    ListGraph& operator= (const ListGraph& _oth){
        if(this == &_oth)
            return *this;

        list_to = _oth.list_to;
        list_from = _oth.list_from;
        v = _oth.v;

        return *this;
    }

    explicit ListGraph(IGraph* _oth) {
        _oth->get_param_m(list_to, list_from, v);
    }

    void AddEdge(int from, int to) override{
        list_to[from].push_back(to);
        list_from[to].push_back(from);
    }

    int VerticesCount() const override{
        return v;
    }

    std::vector<int> Vertices() const override{
        std::vector<int> ver{};

        for(auto it{list_to.begin()}; it != list_to.end(); ++it){
            ver.push_back(it->first);
        }

        return ver;
    }

    std::vector<int> GetNextVertices(int vertex) const override{
        std::vector<int> ver{};
        auto it{list_to.find(vertex)};

        for(int i{}; i < it->second.size(); ++i)
            ver.push_back(it->second[i]);

        return ver;
    }

    std::vector<int> GetPrevVertices(int vertex) const override{
        std::vector<int> ver{};
        auto it{list_from.find(vertex)};

        for(int i{}; i < it->second.size(); ++i)
            ver.push_back(it->second[i]);

        return ver;
    }

    void list_(){
        for(auto it{list_to.begin()}; it != list_to.end(); ++it){
            if(!it->second.empty()) {
                std::cout << it->first << " -> ";
                for (int j{}; j < it->second.size(); ++j) {
                    std::cout << it->second[j] << " ";
                }
                std::cout << std::endl;
            }
        }

        for(auto it{list_from.begin()}; it != list_from.end(); ++it){
            if(!it->second.empty()) {
                std::cout << it->first << " <- ";
                for (int j{}; j < it->second.size(); ++j) {
                    if (!it->second.empty())
                        std::cout << it->second[j] << " ";
                }
                std::cout << std::endl;
            }
        }
    }

    void get_param_l(std::vector<int>& index2Vertex, std::map<int, int>& vertex2Index, std::vector<std::vector<int>>& matrix, int& _v) const override{
        _v = v;
        index2Vertex.resize(_v);
        matrix.assign(v, std::vector<int>(v));
        int i{};

        for(auto it{list_to.begin()}; it != list_to.end(); ++it) {
            index2Vertex.push_back(it->first);
            vertex2Index[it->first] = i++;
        }

        for(auto it{list_to.begin()}; it != list_to.end(); ++it){
            auto it1 = vertex2Index.find(it->first);
            if(!it->second.empty()) {
                for (int j{}; j < it->second.size(); ++j) {
                    auto it2 = vertex2Index.find(it->second[j]);
                    matrix[it1->second][it2->second] = 1;
                }
            }
        }
    }

private:
    std::map<int, std::vector<int>> list_to{};
    std::map<int, std::vector<int>> list_from{};
    int v{};
};

class MatrixGraph : public IGraph{
public:
    ~MatrixGraph() override = default ;

    MatrixGraph() = default;

    void init(std::vector<int>& indexes, int& size){
        index2Vertex = indexes;
        v = size;
        for(int i{}; i < v; ++i)
            vertex2Index[index2Vertex[i]] = i;

        matrix.assign(v, std::vector<int>(v));
        /*
        for(int i{}; i < v; ++i){
            for(int j{}; j < v; j++)
                matrix[i][j] = 0;
        }
         */
    }

    MatrixGraph (const MatrixGraph& _oth) = default;

    explicit MatrixGraph (IGraph* _oth){
        _oth->get_param_l(index2Vertex, vertex2Index, matrix, v);
    }

    MatrixGraph& operator= (const MatrixGraph& _oth){
        if(this == &_oth)
            return *this;

        matrix = _oth.matrix;
        v = _oth.v;

        return *this;
    }

    void AddEdge(int from, int to) override {
        auto it1 = vertex2Index.find(from);
        if(it1 == vertex2Index.end()){
            std::cout << "Incorrect parameter!" << std::endl;
            return;
        }

        auto it2 = vertex2Index.find(to);
        if(it2 == vertex2Index.end()){
            std::cout << "Incorrect parameter!" << std::endl;
            return;
        }

        matrix[it1->second][it2->second] = 1;
    }

    int VerticesCount() const override{
        return v;
    }

    std::vector<int> Vertices() const override{
        std::vector<int> vertices{};
        auto it = vertex2Index.begin();

        for(int i{}; i < v; ++i)
            vertices.push_back((it++)->first);

        return vertices;
    }

    std::vector<int> GetNextVertices(int vertex) const override{
        std::vector<int> vertices{};
        auto it = vertex2Index.find(vertex);
        int _vertex{it->second};

        for(int i{}; i < v; ++i){
            if(matrix[_vertex][i] == 1)
                vertices.push_back(index2Vertex[i]);
        }

        return vertices;
    }

    std::vector<int> GetPrevVertices(int vertex) const override{
        std::vector<int> vertices{};
        auto it = vertex2Index.find(vertex);
        int _vertex{it->second};

        for(int i{}; i < v; ++i){
            if(matrix[i][_vertex] == 1 && i != _vertex)
                vertices.push_back(index2Vertex[i]);
        }
        return vertices;
    }

    void get_param_m(std::map<int, std::vector<int>>& list_to, std::map<int, std::vector<int>>& list_from, int& _v) const override{
        _v = v;
        for(int i{}; i < _v; ++i){
            for(int j{}; j < _v; ++j){
                if(matrix[i][j] == 1){
                    list_to[index2Vertex[i]].push_back(index2Vertex[j]);
                    list_from[index2Vertex[j]].push_back(index2Vertex[i]);
                }
            }
        }
    }

    void list_(){
        for(int i{}; i < v; ++i){
            for(int j{}; j < v; ++j){
                std::cout << matrix[i][j] << " ";
            }
            std::cout << std::endl;
        }
    }

private:
    std::vector<int> index2Vertex{};
    std::map<int, int> vertex2Index{};
    std::vector<std::vector<int>> matrix{};
    int v{};
};

int main() {
    ListGraph l;
    MatrixGraph m;
    std::string command{};
    bool matrix{false}, list{false};

    std::cout << "What will you work with(matrix, list):" << std::endl;
    std::cin >> command;

    if(command == "matrix") matrix = true;
    else if(command == "list") list = true;

    std::cout << "Specify the number of vertices in the graph" << std::endl;
    int ver{};
    std::cin >> ver;

    std::vector<int> indexes{};

    if(matrix){
        int ind{};
        for(int i{}; i < ver; ++i){
            std::cout << "Enter number of vertex " << i + 1 << ":" << std::endl;
            std::cin >> ind;
            indexes.push_back(ind);
        }
    }

   if(matrix)
       m.init(indexes, ver);
   else if(list)
       l.init(ver);

    do {
        std::cout << "Enter command(AddEdge, VCount, V, GetNextV, GetPrevV, list, swap, exit):" << std::endl;
        std::cin >> command;

        if(command == "AddEdge"){
            std::cout << "Specify the vertex of the start and end of the edge:" << std::endl;
            int b{}, e{};
            std::cin >> b >> e;
            if(matrix){
                m.AddEdge(b, e);
                m.list_();
            }
            else if(list){
                l.AddEdge(b, e);
                l.list_();
            }
        }
        else if(command == "VCount") {
            if (matrix)
                std::cout << m.VerticesCount() << std::endl;
            else if (list) {
                std::cout << l.VerticesCount() << std::endl;
            }
        }
        else if(command == "V") {
            if(matrix){
                std::vector<int> vertices = m.Vertices();

                for(int i{}; i < vertices.size(); ++i)
                    std::cout << vertices[i] << " ";
                std::cout << std::endl;
            }
            else if(list){
                std::vector<int> vertices = l.Vertices();

                for(int i{}; i < vertices.size(); ++i)
                    std::cout << vertices[i] << " ";
                std::cout << std::endl;
            }
        }
        else if(command == "GetNextV"){
            std::cout << "Specify the vertex:" << std::endl;
            int vertex{};
            std::cin >> vertex;

            if(matrix){
                std::vector<int> vertices = m.GetNextVertices(vertex);

                if(vertices.empty())
                    std::cout << "0" << std::endl;
                else {
                    for (int i{}; i < vertices.size(); ++i)
                        std::cout << vertices[i] << " ";
                    std::cout << std::endl;
                }
            }
            else if(list){
                std::vector<int> vertices = l.GetNextVertices(vertex);

                if(vertices.empty())
                    std::cout << "0" << std::endl;
                else {
                    for (int i{}; i < vertices.size(); ++i)
                        std::cout << vertices[i] << " ";
                    std::cout << std::endl;
                }
            }
        }
        else if(command == "GetPrevV"){
            std::cout << "Specify the vertex:" << std::endl;
            int vertex{};
            std::cin >> vertex;

            if(matrix){
                std::vector<int> vertices = m.GetPrevVertices(vertex);

                if(vertices.empty())
                    std::cout << "0" << std::endl;
                else {
                    for (int i{}; i < vertices.size(); ++i)
                        std::cout << vertices[i] << " ";
                    std::cout << std::endl;
                }
            }
            else if(list){
                std::vector<int> vertices = l.GetPrevVertices(vertex);

                if(vertices.empty())
                    std::cout << "0" << std::endl;
                else {
                    for (int i{}; i < vertices.size(); ++i)
                        std::cout << vertices[i] << " ";
                    std::cout << std::endl;
                }
            }
        }
        else if(command == "list"){
            if(matrix)
                m.list_();
            else if(list)
                l.list_();
        }
        else if(command == "swap"){
            if(matrix){
                ListGraph l1(&m);
                l = l1;
                l.list_();
                matrix = false;
                list = true;
            }
            else if(list){
                MatrixGraph m1(&l);
                m = m1;
                m.list_();
                list = false;
                matrix = true;
            }
        }
    }while(command != "exit");

    return 0;
}
